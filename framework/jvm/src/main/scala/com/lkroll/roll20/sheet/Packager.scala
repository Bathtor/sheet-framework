/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 Lars Kroll <bathtor@googlemail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package com.lkroll.roll20.sheet

import org.rogach.scallop._
import scala.reflect.runtime.universe
import java.io.{File, FileReader, PrintWriter}

class Conf(arguments: Seq[String]) extends ScallopConf(arguments) {
  version(s"${BuildInfo.name} ${BuildInfo.version}");
  val sheet = opt[String](required = true, descr = "Full name of the Scala object that represents the sheet.");
  val javascript =
    opt[File](required = true, descr = "Path to the javascript file generated by fullOptJS or fastOptJS.");
  val sheetworkers =
    opt[String](required = true, descr = "Full name of the Scala object that contains the sheet workers.");
  val html = opt[File](required = true, descr = "Path to render the HTML and sheetworker JS part to.");
  val css = opt[File](required = true, descr = "Path to render the CSS to.");
  val translation = opt[File](
    required = true,
    descr = "Path to render the translation to (file name should be translation.json for Roll20 repo autodetect)."
  );
  verify()
}

object Packager extends App {

  val sheetWorkerStart = "<script type=\"text/worker\">";
  val sheetWorkerEnd = "</script>";
  val bufferSize = 100000;

  val conf = new Conf(args);
  val res = for {
    sheetName <- conf.sheet.toOption;
    sheet <- resolveSheet(sheetName);
    javascript <- conf.javascript.toOption;
    sheetworkers <- conf.sheetworkers.toOption;
    html <- conf.html.toOption;
    css <- conf.css.toOption;
    translation <- conf.translation.toOption
  } yield {
    packageSheet(sheet, sheetworkers, javascript, html, css, translation);
    ()
  }
  res match {
    case Some(_) => println("Done."); System.exit(0);
    case None => {
      println("One or more required Parameters are missing.");
      conf.printHelp();
      System.exit(1);
    }
  }

  def packageSheet(sheet: Sheet, html: File, css: File, translation: File) {
    val htmlWriter = new PrintWriter(html);
    val cssWriter = new PrintWriter(css);
    val translationWriter = new PrintWriter(translation);
    try {
      htmlWriter.write(sheet.render);
      cssWriter.write(sheet.renderStyle());
      translationWriter.write(sheet.renderTranslation());
    } finally {
      htmlWriter.close();
      cssWriter.close();
      translationWriter.close();
    }
  }

  def packageSheet(sheet: Sheet, sheetworkers: String, javascript: File, html: File, css: File, translation: File) {
    val jsReader = new FileReader(javascript);
    val htmlWriter = new PrintWriter(html);
    val cssWriter = new PrintWriter(css);
    val translationWriter = new PrintWriter(translation);
    try {
      htmlWriter.write(sheet.render);
      htmlWriter.println(sheetWorkerStart);
      val buffer = new Array[Char](bufferSize);
      println(s"Copying javascript of size ${javascript.length()}");
      var read: Int = jsReader.read(buffer);
      while (read > -1) {
        println(s"Read $read bytes...");
        htmlWriter.write(buffer, 0, read);
        read = jsReader.read(buffer);
      }
      println("Finished writing javascript.");
      htmlWriter.println(s"$sheetworkers().load();");
      htmlWriter.println(sheetWorkerEnd);
      cssWriter.write(sheet.renderStyle());
      translationWriter.write(sheet.renderTranslation());
    } finally {
      htmlWriter.close();
      cssWriter.close();
      jsReader.close();
      translationWriter.close();
    }
  }

  def resolveSheet(sheetName: String): Option[Sheet] = {
    try {
      val cl = Thread.currentThread().getContextClassLoader;
      val runtimeMirror = universe.runtimeMirror(cl);
      val module = runtimeMirror.staticModule(sheetName);
      val obj = runtimeMirror.reflectModule(module);
      val sheet: Sheet = obj.instance.asInstanceOf[Sheet];
      Some(sheet)
    } catch {
      case e: Throwable => e.printStackTrace(System.err); None
    }
  }

}
